# PA4: Graphs - Six Degrees of Kevin Bacon

## Overview

- [PA4: Graphs - Six Degrees of Kevin Bacon](#pa4-graphs---six-degrees-of-kevin-bacon)
  - [Due Date: Thursday 11:59pm, September 5th, 2019](#due-date-thursday-1159pm-september-5th-2019)
  - [Overview](#overview)
    - [Motivation of PA](#motivation-of-pa)
    - [Background / Game Overview](#background--game-overview)
  - [Getting Started](#getting-started)
    - [Important Notes about imdb_2019.tsv](#important-notes-about-imdb2019tsv)
  - [Part 1-A: Pathfinder on Unweighted Graph](#part-1-a-pathfinder-on-unweighted-graph)
    - [1. Design and implement your node and edge classes](#1-design-and-implement-your-node-and-edge-classes)
    - [Write a program called pathfinder (in pathfinder.cpp) to find the shortest path from one actor to another actor through shared movies](#write-a-program-called-pathfinder-in-pathfindercpp-to-find-the-shortest-path-from-one-actor-to-another-actor-through-shared-movies)
  - [Part 1-A: Pathfinder on Weighted Graph](#part-1-a-pathfinder-on-weighted-graph)
    - [1. Complete your pathfinder program by implementing the "weighted edges" version of your program, where the edge weight is the age of the movie](#1-complete-your-pathfinder-program-by-implementing-the-%22weighted-edges%22-version-of-your-program-where-the-edge-weight-is-the-age-of-the-movie)
    - [2. Questions on verifying "Six Degrees of Kevin Bacon"](#2-questions-on-verifying-%22six-degrees-of-kevin-bacon%22)
  - [Part 2: Pathfinder on Unweighted Graph](#part-2-pathfinder-on-unweighted-graph)
    - [Part 2: movietraveler to find MST](#part-2-movietraveler-to-find-mst)
  - [Running time restrictions, hints and warnings](#running-time-restrictions-hints-and-warnings)
    - [Running Time](#running-time)
    - [Hints and Warning](#hints-and-warning)
      - [Hints](#hints)
      - [Warning](#warning)
  - [Extra Credit : Complete CAPE](#extra-credit--complete-cape)
  - [Submission instructions](#submission-instructions)

### Background / Game Overview

"Six Degrees of Kevin Bacon" is a parlor game based on the "six degrees of separation" concept, which proposes that any two people on Earth are six or fewer acquaintance-links apart. This idea eventually morphed into a parlor game where movie buffs challenge each other to find the shortest path between some arbitrary actor and Hollywood actor Kevin Bacon. It rests on the assumption that anyone involved in the Hollywood film industry can be linked through their film roles to Bacon in six or fewer steps. The game requires a group of players to try to connect any such individual to Kevin Bacon as quickly and in as few links as possible.  In the first part of the assignment, you will implement the generalized version of the Kevin Bacon game.

## Getting Started

**Files Provided:**

Starter Code:

1. `Makefile` - which you should modify as you add source code and modify the initial dependencies
2. `ActorGraph.hpp/cpp` -   contains starter code that reads in imdb_2019.tsv

Files to test your code:

1. `imdb_2019.tsv` - The database that contains the majority of actors/ actresses found in IMDb. See the notes below for more details.
2. `imdb_small_sample.tsv` - The database that contains a small set of actors/ actresses found in IMDb.
3. `random_pair.tsv` - Text file that  contains 100 pair of actors you can use for testing.
4. `test_pairs.tsv` - Text file containing the pairs of actors to find paths/connections(details explained later)
5. `out_paths_unweighted.tsv` - Output file generated by Pathfinder that stores the results from finding the unweighted shortest path between two actors in test_pairs.tsv
6. `out_paths_weighted.tsv`  - Output file generated by Pathfinder that stores the results from finding the weighted shortest path between two actors in test_pairs.tsv
7. `refpathfinder` - Solution executable that implements Pathfinder
8. `refmovietraveler` - Solution executable that implements Movietraveler

The files above can be found in the following directory `/home/linux/ieng6/cs100s219/public/pa4_ref`

### Important Notes about imdb_2019.tsv

We have provided you a tab-separated file that contains the majority of actors/actresses found in IMDb and the movies they have played in. Specifically, the file looks like this ("TAB" denotes a single tab character):

``` txt
Actor/Actress<TAB>Movie<TAB>Year
Kevin Bacon<TAB>Queens Logic<TAB>1991
Kevin Bacon<TAB>She's Having a Baby<TAB>1988
Kevin Bacon<TAB>Balto<TAB>1995
Kevin Bacon<TAB>Diner<TAB>1982
Kevin Bacon<TAB>Loverboy<TAB>2005
Kevin Bacon<TAB>Rails & Ties<TAB>2007
Kevin Bacon<TAB>Where the Truth Lies<TAB>2005
Kevin Bacon<TAB>Sleepers<TAB>1996
...
```

a) The first column contains the name of the actor/actress, the second column contains the name of a movie they played in, and the last column contains the year the movie was made.

b) Each line defines a single actor→movie relationship in this manner (except for the first line, which is the header). You may assume that actor→movie relationships will be grouped by actor name, but do not assume they will be sorted.

c) Note that multiple movies made in different years can have the same name, so use movie year as well as title when checking if two are the same.

d) Make sure you DO NOT format the names of actors or movies beyond what is given in the tab-separated input file. In other words, each actor's name should be taken exactly as the actor's name appears in the imdb_2019.tsv file. You do not have to (and should not) mess with it. During grading, the actor's name in the test file will match the actor's name in the imdb_2019.tsv file.

**Note: The imdb_2019.tsv file is pretty big, so please do not upload it upon submission.**

## Part 1-A: Pathfinder on Unweighted Graph

### 1. Design and implement your node and edge classes

In order to complete the rest of the assignment, you must first design your graph structure and implement the necessary classes. In your graph, each actor/actress will define a single node. Two nodes (i.e., actors) will be connected by an undirected edge if the corresponding actors played in the same movie.  Multiple undirected edges can exist between the same two nodes (which would imply that the two actors played in multiple movies together).

**Implementation Checklist:**

* **Review ActorGraph.cpp:** This contains starter code to read the imdb_2019.tsv file (the code opens a file and parses the actor/movie/year from each line). For the implementations below, you may have to create separate .cpp files for your different classes based on your design
* **Design/Implement your node objects (actors/actresses):** What information does your node need to contain?
* **Design/Implement your "edges":** How will you connect actors (nodes), relationships (edges), and movies to each other that allows efficient traversal of the graph without needlessly copying whole objects around? Do you want to have a data structure for edges or merely represent them as connections between two nodes?  Pointers and/or vector indices might come in handy…
* **Modify the given Makefile** so that it works for your files
* **Test your graph implementation:** load the imdb_2019.tsv file, you should expect to find 413,105 actors or nodes, 325,382 movies, and 5,874,252 directed edges. Note: if we implement our graph with directed edges, every undirected edge will be represented by two directed edges
* Check to make sure you d**id NOT use any pre-built data structures**, like the Boost Graph Library (BGL), besides what is provided in the [C++ STL data structures](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Fstl%2F&sa=D&sntz=1&usg=AFQjCNFZRl2frO480rJueOYXTNviHbYuvA)
* You may assume the input dataset and query file is formatted well, and **no illegally formatted** file will be used to test against your program

### Write a program called pathfinder (in pathfinder.cpp) to find the shortest path from one actor to another actor through shared movies

**Implementation Checklist:**

* implement pathfinder to work on an unweighted graph (see ./pathfinder Details below for more information)
* Check the Runtime Restriction part at the end of this PA

**./pathfinder Details:**

Your program should be called like this (see detailed explanation of arguments below):

`./pathfinder imdb_2019.tsv u test_pairs.tsv out_paths_unweighted.tsv`

where `test_pairs.tsv` contains:

``` txt
Actor1/Actress1<TAB>Actor2/Actress2
Robert Downey Jr.<TAB>Chris Evans
Amy Adams<TAB>Nicole Kidman
Will Smith<TAB>Bruce Willis
James McAvoy<TAB>Michael Fassbender
Djimon Hounsou<TAB>50 Cent

```

and your program produces an output file out_paths_unweighted.tsv containing the following (See the expected formatting details of the output file below):

``` txt
(actor)--[movie#@year]-->(actor)--...
(Robert Downey Jr.)--[Avengers: Age of Ultron#@2015]-->(Chris Evans)
(Amy Adams)--[Leap Year#@2010]-->(Matthew Goode)--[Stoker#@2013]-->(Nicole Kidman)
(Will Smith)--[Concussion#@2015]-->(Alec Baldwin)--[Mercury Rising#@1998]-->(Bruce Willis)
(James McAvoy)--[X-Men: First Class#@2011]-->(Michael Fassbender)
(Djimon Hounsou)--[Elephant White#@2011]-->(Kevin Bacon)--[Sleepers#@1996]-->(Robert De Niro)--[Freelancers#@2012]-->(50 Cent)

```

`./pathfinder` will take 4 command-line arguments:

1. Name of text file containing the tab-delimited movie casts (such as imdb_2019.tsv).
2. Lower-case character u or w
    1. u -- builds the graph with unweighted edges
    2. w -- builds the graph with weighted edges (you should implement unweighted part first)
3. Name of text file containing the pairs of actors to find paths, where first line in the file is a header, and each row contains the names of the two actors separated by a single tab character
4. Name of output text file. Pathfinder will create a new file to store the results from finding the shortest path between two actors
5. The output text file should follow this **exact format** detailed here. First line of the file is a header, and each row contains the paths for the corresponding pair of actors and input pairs file (in the same order).  Each path should be formatted as follows: `(<actor name>)--[<movie title>#@<movie year>]-->(<actor name>)--[<movie title>#@<movie year>]-->(<actor name>)`....etc where the movie listed between each pair of actors is one where they both had a role.

**Notes:**

1. The specific path your pathfinder program outputs may be different than from reference solution. But the **total path weights** must be the same.
2. You may ONLY use C++ STL data structures and NOT the Boost Graph LIbrary (BGL).
3. We will not test you on the shortest path between an actor/actress and himself or herself, feel free to handle this case at your will.

### 1. Complete your pathfinder program by implementing the "weighted edges" version of your program, where the edge weight is the age of the movie

(This is because we will want to choose newer movies over older movies when connecting two actors).

**Implementation Checklist:**

* Make pathfinder work for weighted graphs (see below for details)
* Test against reference solution refpathfinder
* Check the Runtime Restriction part at the end of this PA

If we are defining an edge between two actors that played in a movie made in year Y, then the weight of that edge will be:

`weight = 1 + (2019 - Y)`

Note that we are using **2019**, which is because the dataset only contains movies released in **2019** and earlier. **Don't accidentally use other year number!**

Example:

`./pathfinder imdb_2019.tsv w test_pairs.tsv out_paths_weighted.tsv`

should produce an output file out_paths_weighted.tsv containing the following (although the particular movies may not match, the total path weights should match your output):

``` unix
(actor)--[movie#@year]-->(actor)--...
(Robert Downey Jr.)--[Avengers: Endgame#@2019]-->(Chris Evans)
(Amy Adams)--[The Woman in the Window#@2019]-->(Anthony Mackie)--[The Banker#@2019]-->(Nicholas Hoult)--[The True History of the Kelly Gang#@2019]-->(Russell Crowe)--[Boy Erased#@2018]-->(Nicole Kidman)
(Will Smith)--[Spies in Disguise#@2019]-->(Ben Mendelsohn)--[Captain Marvel#@2019]-->(Samuel L. Jackson)--[Glass#@2019]-->(Bruce Willis)
(James McAvoy)--[X-Men: Apocalypse#@2016]-->(Michael Fassbender)
(Djimon Hounsou)--[King Arthur: Legend of the Sword#@2017]-->(Charlie Hunnam)--[Triple Frontier#@2019]-->(Oscar Isaac)--[The Addams Family#@2019]-->(Charlize Theron)--[Long Shot#@2019]-->(O'Shea Jackson Jr.)--[Den of Thieves#@2018]-->(50 Cent)

```

***The specific path your pathfinder program outputs may be different than from reference solution. As long as the total path weights are the same, then you are fine. However, you must follow the exact format as above for your output file.***

To efficiently implement Dijkstra's algorithm for shortest path in a weighted graph, you should make use of a priority queue. You can implement your own, or use the STL C++ implementation: http://www.cplusplus.com/reference/queue/priority_queue/. Note that it does not support an update_priority operation (how can you get around that?). Think about what happens if you insert the same key twice into the heap, but with a lower priority. Which one gets popped first? When you pop a key-priority pair, how do you know if it is valid/up-to-date or not?

### 2. Questions on verifying "Six Degrees of Kevin Bacon"

It was claimed that anyone involved in the Hollywood film industry can be linked through their film roles to Kevin Bacon within six steps. You are suspicious of such claim and decide to verify it using the given dataset.

Create a file named **readme.md** to answer the following questions, you may use pseudocode to help you explain the question but make sure to include your own description as well:

1. Before you start to verify the claim, you first notice that it is not possible for this claim to be true if the actor graph is not even connected. We define a **connected component** of an undirected graph as a **largest subgraph in which any two vertices are reachable to each other by a path.** For example, the following graph contains two connected components:

Explain how you can verify a given undirected graph is connected (i.e all the vertices are in a same connected components). You should also include the runtime of your algorithm.

2. If the given undirected graph is not connected, then some vertices must be in different connected components. Explain how you can find the number of connected components in an undirected graph. You should also include the runtime of your algorithm.

3. Now that you know how to verify that the actor graph defined by the given dataset is connected (the actor graph is indeed connected) , explain how can you further verify the claim of "Six Degrees of Kevin Bacon", that is: in the actor graph, each actor/actress is connected to Kevin Bacon with a path that contains no more than 6 edges. You should also include the runtime of your algorithm.

(Once you finished the whole assignment, if you are interested, you can try implementing your answers above and see the results by yourself. We will only grade your readme questions so this is entirely **optional**.)

## Part 2: Pathfinder on Unweighted Graph

### Part 2: movietraveler to find MST

*It's almost end of summer. Waking up and preparing to take on the challenge of PA4 Part 2, you find the environment very abnormal: half of the Geisel Library is buried in snow! Just as you are petrified by the scene and start to feel the chilling cold, you see Leonardo DiCaprio crawling in the snow holding a riffle against the Geisel Library. It suddenly occurs to you that you are actually in the 2010 sci-fi action movie **Inception**! (It's real. Geisel Library was the prototype of the snow fortress scene in the movie.) Suprisingly shaking his hand in thrill, the scene suddenly changes: A ferocious grizzly bear rushes toward you and attacks Leonardo DiCaprio! You "movie-jumped" into **The Revenant**, a 2015 American western movie also starred by Leonardo DiCaprio......*

*You realize that you just get the superpower of **traveling across movie universes**! To make your classmates in CSE 100 believe in your super power, you decide to meet all the actors and actresses in imdb_2019.tsv dataset in movie and get autographs for them. However, you find out that the older the movie is, the more calories "movie-traveling" drains from your body. Having a limit budget on your lunch money, you need to only travel to a small set of movies which are also as recent as possible. Also, because the movie stars are super-busy, for each time of "movie-traveling", you can only get 1 more autograph by letting an actor/actress who you have visited introduce you to one of their co-stars in the movie. Therefore, You want to show your fellow peers the routes through movie universes that you took to efficiently obtain all of the autographs.*

*movietraveler should answer the following query: **for a dataset formatted as `actor/actress<tab>movie<tab>year` where all the actors and actresses are connected: "What is your optimal route to connected all the actors and actresses?"** By connected, we mean that there exists a path between all actors in the equivalent movie graph (similar to that constructed in Part 1); by optimal, we mean that the sum of the edge (movie) weights (remember `1 + (2019 - Y)` in part 1) should be minimal and the edges should connect all the actors in the dataset; by route, we mean a set of **edges**, each containing the information of 2 actors/actresses being connected and the movie that connects them.*

**Implementation Checklist:**

* Implement movietraveler to work on a connected, edge-weighted, undirected actor/actress graph (see details below for more information)
* Check the Runtime Restriction part at the end of this PA

**Implementation Requirements:**

* **You must solve the movie traveler problem by finding a minimum spanning tree using Kruskal's algorithm. To make your algorithm efficient, you must implement union find data structure with path compression and union by size/height to help you in Kruskal's.**
* You may build your union find data structure on top of your completed data structure for Part 1. However, in doing so, it is also your responsibility to ensure both pathfinder and movietraveler works for testing
* The complete actor graph defined by the dataset imdb_2019.tsv is a **connected and undirected graph**. In this graph, the number of undirected edges is more than 7 times than the number of vertices. Given this information, **think about when you should stop building MST without always checking all the undirected edges** to make your Kruskal's more efficient

**movietraveler will take 2 command-line arguments:**

1. The first argument is the name of a text file containing the movie casts in the same format as imdb_2019.tsv. **Again, this file is quite large (54.1M), so you should create smaller versions to test your implementation as a first step.**
2. The second argument is the name of the output file containing the information of your minimum spanning tree. Each line of the output file is defined by an edge with the format: `(actor)<--[movie#@year]-->(actor)` and the last three lines  contain the relevant data such as total weight of all the edges in your MST. Refer to the output file below for a complete format example.

**movietraveler Outputs:**

For example,

`./movietraveler imdb_small_sample.tsv out_traveler_path.tsv`

should run your code  to produce an output file `out_traveler_path.tsv` containing the following:

``` txt
(actor)<--[movie#@year]-->(actor)
(James McAvoy)<--[Glass#@2019]-->(Samuel L. Jackson)
(Samuel L. Jackson)<--[Avengers: Endgame#@2019]-->(Robert Downey Jr.)
(Michael Fassbender)<--[Alien: Covenant#@2017]-->(Katherine Waterston)
(Robert Downey Jr.)<--[Spider-Man: Homecoming#@2017]-->(Tom Holland)
(Tom Holland)<--[The Current War#@2017]-->(Katherine Waterston)
(Kevin Bacon)<--[X-Men: First Class#@2011]-->(James McAvoy)
#NODE CONNECTED: 7
#EDGE CHOSEN: 6
TOTAL EDGE WEIGHTS: 20
```

We have provided a reference solution `refmovietraveler` for you to test again your program. It is fine that your edges are not exactly the same as reference output (because there might be multiple correct minimum spanning tree of a same graph, and also the order of the edges might be different), but your total edge weight (using formula `1 + (2019 - Y)`) calculated from the edges in your MST will be the same as your "`TOTAL EDGE WEIGHTS`" and it should be the minimal possible.

During testing, we will simply build a new graph based on your output edges and see if the result defines a MST that gives the correct total minimum weight as our reference solution.

## Running time restrictions, hints and warnings

### Running Time

We will predominantly test your program with smaller versions of this file (as should you) containing <100 nodes. As a rule of thumb, we expect that your program runs in l**ess than 2x the runtime of the reference**, so ensure that it does. Practically, this is because your code might time out if it takes far too long, but realistically, the purpose of this course is to implement fast algorithms, so within twice the time of the reference solution should be reasonable, if not expected.

*In general, aim for the reference run times or better.*

**For Pathfinder:**

Anything more than 2x the reference solution may receive a penalty.

**For Movietraveler:**

We expect your solutions to run under 1 minute for any of the provided input files, the largest of which is the imdb_2019.tsv database. The reference solution runs in less than 30 seconds. No deductions for this part unless your solution takes a really long to run (say 2 to 3 minutes)

If your implementation is slow compared to the reference program, check the following things:

* Make sure you implement path compression for movietraveler
* Make sure you don't have any accidental inefficient operations (e.g. linear search) in any part of your code
* Consider the space efficiency of your program.  Often, in C++, memory issues are the cause of running time inefficiencies:
  * Get rid of all data you don't need to store; perhaps you are storing redundant data
  * Use references instead of values

#### Hints

1. Remember that a hash table is given to you as a [std::unordered_set](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Funordered_set%2Funordered_set%2F&sa=D&sntz=1&usg=AFQjCNFrJGQ6jUH1gjikuNzSNz3ITIvitw) and a hash map is given to you as a [std::unordered_map](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Funordered_map%2Funordered_map%2F&sa=D&sntz=1&usg=AFQjCNEFef5XWq91AE2DXpCZkTkY4rw0TQ). You may NOT use any pre-built data structures, like the Boost Graph Library (BGL), besides what is provided in the [C++ STL data structures](http://www.google.com/url?q=http%3A%2F%2Fwww.cplusplus.com%2Freference%2Fstl%2F&sa=D&sntz=1&usg=AFQjCNFZRl2frO480rJueOYXTNviHbYuvA).
2. Write your own Makefile to make compilation easier.
3. Compilation problems? Try having a target .o file for each hpp file that corresponds to a class. For example:
    1. ActorGraph.o: ActorGraph.hpp Movie.o ActorNode.o OtherClass.o
    2. Movie.o: Movie.hpp
    3. ActorNode.o: ActorNode.hpp
    4. OtherClass.o:  OtherClass.hpp


1. We define a connected component of an undirected graph as a largest subgraph
   in which any two vertices are reachable to each other by a path. For example
   the following graph contains two connected components:

   Explain how you can verify a given undirected graph is connected
   (i.e all the vertices are in a same connected components).

   You should also include the runtime of your algorithm

Starts with the random Node, and run BFS and count the number of visited nodes.
if the count is same as total number of nodes, it is fully connected;

Run time would be O(#Edges + #Nodes)

2. If the given undirected graph is not connected, then some vertices must be
   in different connected components. Explain how you can find the number of
   connected components in an undirected graph.

   You should also include the runtime of your algorithm.

By using Union-find, union edges if they are connected. Then, store all
parents of nodes in unordered set. Then, the number of elements in sets
would be the number of connected components.

Run time would be O(#Edges + #Nodes)
	- if you do path compression when find.

3. Now that you know how to verify that the actor graph defined by the given
   dataset is connected (the actor graph is indeed connected), explain how can
   you further verify the claim of "Six Degrees of Kevin Bacon", that is:
   in the actor graph, each actor/actress is connected to Kevin Bacon with a
   path that contains no more than 6 edges. You should also include the runtime
   of your algorithm

Run BFS from Kevin Bacon and count, up to depths of 6.
Then compare the total number of nodes with the count.
If they are same the claim is true, false otherwise.

Run time would be O(#Edges + #Node)
